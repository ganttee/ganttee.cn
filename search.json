[{"categories":["golang"],"content":"介绍 Go是一种快速的编译型语言，它具有高效的内存管理和并发编程的能力。在某些情况下，我们需要使用C或C++的代码库来扩展Go程序的功能。Go通过CGO允许我们在Go代码中调用C函数并在C代码中调用Go函数，这使得Go更加灵活和强大。本文将介绍CGO的简单使用，包括动态和静态库的代码示例及编译运行。\n简要说明 CGO是Go提供的一个工具，它允许Go代码与C语言代码进行交互。CGO允许我们使用C函数，变量和数据结构，它还可以将Go代码编译成C代码，使得Go和C可以在同一个二进制文件中运行。CGO的一个重要应用是使用现有的C库，以便快速地将其与Go集成在一起。CGO还可以用于将Go代码作为C库的插件。\n动态库代码示例及编译运行 下面的示例演示了如何使用CGO在Go中调用动态链接库中的C函数。\n首先，我们编写一个C语言的源文件，它包含了一个简单的函数。在这个例子中，我们将创建一个名为sum的函数，它将两个整数相加并返回结果。\n1 2 3 4  // sum.c int sum(int a, int b) { return a + b; }   接下来，我们需要将这个C文件编译成动态库，以便在Go代码中调用。下面是使用gcc编译器将sum.c编译成动态库的命令：\n1  gcc -shared -o libsum.so sum.c   现在，我们已经有了一个动态链接库，我们可以在Go代码中调用它。下面是一个示例Go代码，它导入C库并调用sum函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // main.go package main // #cgo LDFLAGS: -L. -lsum // int sum(int a, int b); import \"C\" import \"fmt\" func main() { a := 1 b := 2 c := int(C.sum(C.int(a), C.int(b))) fmt.Printf(\"%d + %d = %d\\n\", a, b, c) }   让我们来看看这个Go代码的关键部分：\n1 2 3  // #cgo LDFLAGS: -L. -lsum // int sum(int a, int b); import \"C\"   这个部分告诉CGO我们需要链接一个名为libsum.so的库，同时还导入了sum函数的声明。\n现在我们可以使用以下命令编译和运行这个程序：\n1  go build \u0026\u0026 ./main   输出应该为：\n1 + 2 = 3 静态库代码示例及编译运行 下面的示例演示了如何使用CGO在Go中调用静态链接库中的C函数。\n首先，我们编写一个C语言的源文件，它包含了一个简单的函数。在这个例子中，我们将创建一个名为multiply的函数，它将两个整数相乘并返回结果。\n1 2 3 4  // multiply.c int multiply(int a, int b) { return a * b; }   接下来，我们需要将这个C文件编译成静态库，以便在Go代码中调用。下面是使用gcc编译器将multiply.c编译成静态库的命令：\n1 2  gcc -c multiply.c -o multiply.o ar rcs libmultiply.a multiply.o   现在，我们已经有了一个静态链接库，我们可以在Go代码中调用它。下面是一个示例Go代码，它导入C库并调用multiply函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // main.go package main // #cgo LDFLAGS: -L. -lmultiply // int multiply(int a, int b); import \"C\" import \"fmt\" func main() { a := 3 b := 4 c := int(C.multiply(C.int(a), C.int(b))) fmt.Printf(\"%d * %d = %d\\n\", a, b, c) }   让我们来看看这个Go代码的关键部分：\n1 2 3  // #cgo LDFLAGS: -L. -lmultiply // int multiply(int a, int b); import \"C\"   这个部分告诉CGO我们需要链接一个名为libmultiply.a的库，同时还导入了multiply函数的声明。\n现在我们可以使用以下命令编译和运行这个程序：\n1  go build \u0026\u0026 ./main   输出应该为：\n3 * 4 = 12 Go调用C以及C调用Go的示例 在上面的示例中，我们演示了如何在Go中调用C函数，下面我们将演示如何在C代码中调用Go函数。\n首先，我们编写一个Go函数，它将返回两个整数的和。\n1 2 3 4 5 6 7 8 9 10 11  // sum.go package main import \"C\" //export Sum func Sum(a, b int) int { return a + b } func main() {}   注意到我们在函数前面加了一个注释：//export Sum，这是告诉CGO我们需要将这个函数导出成C函数，以便在C代码中调用。函数名必须是以大写字母开头的。\n接下来，我们需要将Go代码编译成动态链接库，以便在C代码中调用。下面是使用go命令将sum.go编译成动态库的命令：\n1  go build -buildmode=c-shared -o libsum.so sum.go   现在，我们已经有了一个动态链接库，我们可以在C代码中调用它。下面是一个示例C代码，它调用了Go代码中的Sum函数：\n1 2 3 4 5 6 7 8 9 10 11  // main.c #include \u003cstdio.h// declare the function prototypeextern int Sum(int a, int b); int main() { int a = 3; int b = 4; int c = Sum(a, b); printf(\"%d + %d = %d\\n\", a, b, c); return 0; }   在这个示例中，我们使用extern关键字声明了Sum函数的原型，然后在main函数中调用它。请注意，我们没有包含任何头文件或库文件，因为我们使用CGO直接调用了动态链接库中的函数。\n接下来，我们需要将C代码编译成可执行文件，并链接动态链接库。下面是使用gcc编译器将main.c编译成可执行文件的命令：\n1  gcc -o main main.c -L. -lsum   现在，我们可以运行这个可执行文件，并看到输出：\n1 2  ./main 3 + 4 = 7   这个示例演示了如何使用CGO在C代码中调用Go函数，它非常有用，因为有些功能很难在C中实现，但在Go中很容易实现。\n总结 在本文中，我们介绍了如何使用CGO在Go中调用C函数和在C中调用Go函数。我们使用了静态链接库和动态链接库，演示了在编译和链接时如何使用CGO指令。CGO可以非常方便地在Go和C之间进行交互，但需要注意一些细节。希望本文对你理解CGO有所帮助。\n","description":"","tags":["go","golang","cgo"],"title":"go cgo 简单使用","uri":"/posts/useful-golang-cgo/"},{"categories":null,"content":"新版本的xlrd不支持读取xlsx的Excel文件了，那么只需要回退版本即可。 解决办法如下：\n1 2  pip uninstall xlrd pip install xlrd==1.2.0   ","description":"","tags":["python","xlrd","xlsx","excel"],"title":"Python Xlrd不支持xlsx","uri":"/posts/python-xlrd%E4%B8%8D%E6%94%AF%E6%8C%81xlsx/"},{"categories":["git"],"content":"1.创建一个空白的分支的需求 在Git中创建分支，是必须有一个父节点的，也就是说必须在已有的分支上来创建新的分支，如果工程已经进行了一段时间，这个时候是无法创建空分支的。但是有时候就是需要创建一个空白的分支。\n2.解决方法： 2.1 使用 git checkout的--orphan参数: git checkout --orphan emptybranch 该命令会生成一个叫emptybranch的分支，该分支会包含父分支的所有文件。但新的分支不会指向任何以前的提交，就是它没有历史，如果你提交当前内容，那么这次提交就是这个分支的首次提交。\n2.2 删除所有文件： 想要空分支，所以需要把当前内容全部删除，用git命令\ngit rm -rf . //注意：最后的‘.’不能少。 2.3 提交分支： 如果没有任何文件提交的话，分支是看不到的，所以我们需要创建一个新文件，然后提交则新创建的branch就会显示出来。\necho '# new branch' \u003e\u003e README.md git add README.md git commit -m 'new branch' 2.4 最后push到远程仓库，则新的空分支就创建成功了。 git push origin emptybranch 参考：https://www.jianshu.com/p/a18487d987ac\n","description":"","tags":["git"],"title":"Git创建一个空白的分支","uri":"/posts/git%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9A%84%E5%88%86%E6%94%AF/"},{"categories":["爬虫"],"content":"开源爬虫库很多，功能都差不多，比如大部分都不支持JS动态加载的页面:)，但是现在大部分网页都是JS动态加载的。后文以Python为例介绍几种支持JS动态加载网页的爬取方法。\n什么是网络爬虫？ 网络爬虫一般指通过技术抓取公开网站网页上数据。\n如何在爬虫时，支持JS动态加载的页面？ 定制开发---性能高但开发成本及灵活性低  原理: 定向分析所要爬取的网页，用Python模拟JS的行为\n 使用一些浏览器自动化框架/库来爬取站点---通用性高开发成本低且灵活但效率低  原理: 模拟浏览器处理JS。利用外部JS Engine执行JS，并获取其结果\n 1.Selenium WebDriver  Selenium 是一系列工具和库的综合项目，这些工具和库支持 web 浏览器的自动化。 WebDriver 以本地化方式驱动浏览器，就像用户在本地或使用 Selenium 服务器的远程机器上所做的那样，这标志着浏览器自动化的飞跃。 Selenium WebDriver 指的是语言绑定和各个浏览器控制代码的实现。 这通常被称为 WebDriver。\n Requestium\n2.dryscrape  dryscrape is a lightweight web scraping library for Python. It uses a headless Webkit instance to evaluate Javascript on the visited pages. This enables painless scraping of plain web pages as well as Javascript-heavy “Web 2.0” applications like Facebook. dryscrape 是一个轻量级的 Python 网页抓取库。它使用无头 Webkit 实例来评估访问页面上的 Javascript。这使得可以轻松抓取普通网页以及像 Facebook 这样的 Javascript 密集型“Web 2.0”应用程序。\n 1 2 3 4 5 6 7 8  def get_url_dynamic2(url): driver=webdriver.Firefox() #调用本地的火狐浏览器，Chrom 甚至 Ie 也可以的 driver.get(url) #请求页面，会打开一个浏览器窗口 html_text=driver.page_source driver.quit() #print html_text return html_text get_text_line(get_url_dynamic2(url)) #将输出一条文本   3.Splash  Splash is a javascript rendering service. It's a lightweight browser with an HTTP API, implemented in Python using Twisted and QT. Splash 是一个 javascript 渲染服务。它是一个带有 HTTP API 的轻量级浏览器，使用 Twisted 和 QT 在 Python 中实现。 最简单的使用方法是docker起一个Splash容器，然后调用Splash HTTP接口，详见官方说明。\n 1.Pull the image: $ sudo docker pull scrapinghub/splash 2.Start the container: $ sudo docker run -it -p 8050:8050 --rm scrapinghub/splash 3.Splash is now available at 0.0.0.0 at port 8050 (http). 4.Pyppeteer puppeteer JavaScript（无头）chrome/chromium 浏览器自动化库的非官方 Python 端口 具体用法见官方说明\n","description":"","tags":["爬虫","selenium","splash"],"title":"Python Spider Js Render","uri":"/posts/python-spider-js-render/"},{"categories":["web"],"content":" 最近做项目的时候，有前端WEB页面需求，自己就又码了前端😂，用了bootstrap。今天遇到一个坑，记录一下。\n html页面用bootstrap按钮组件的时候，每次按钮按下以后，页面会自动刷新，百思不得其解。折腾了半天，才发现是因为按钮的属性设置导致的。\n在bootstrap中，按钮的type要设置为button，如果不设置或者设置为submit都会在click事件后，触发自动刷新页面。 解决办法也一目了然了，将\n1  \u003cbutton type=\"submit\" class=\"btn btn-primary\" id=\"btn-play\"\u003e播放\u003c/button\u003e   改为\n1  \u003cbutton type=\"button\" class=\"btn btn-primary\" id=\"btn-play\"\u003e播放\u003c/button\u003e   即可。😊\n","description":"","tags":["web","bootstrap","html","button"],"title":"bootstrap中点击按钮会自动刷新页面","uri":"/posts/1/"},{"categories":null,"content":"// Todo ","description":"","tags":null,"title":"About","uri":"/about/"}]
